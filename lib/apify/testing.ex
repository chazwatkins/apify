defmodule Apify.Testing do
  @moduledoc """
  Support for interacting with the client in a test environment

  > #### Note {:.info}
  >
  > The default method of tracking and mocking API calls uses the process dictionary for storage.
  > This means that tests can be run async (calls from one process will not affect calls from
  > another). However, it also means that calls from an async task will not be tracked by the test
  > process. If mocks and calls need to extend past the test process boundary, use `shared: true`
  > on the call to `use Apify.Testing` or in individual calls to `mock_apify` and `assert_apify_called`.

  ## Usage

  The testing facility provided by this library has two parts: this module, which provides helpful
  functions for generating data and asserting that API calls are made, and
  `Apify.Plugin.TestClient`, which provides a basic mock and support for the test assertions.

  In your test environment, you likely want to use the test client plugin as the only item in the
  client stack:

      # config/test.exs
      config :apify, stack: [{Apify.Plugin.TestClient, :request, []}]

  The stack can also be configured at runtime by passing the `:stack` option to any operation.

  Then, in your test file, `use` this module and make use of the available assertions:

      defmodule MyApp.MyTest do
        use ExUnit.Case
        use Apify.Testing

        test "something" do
          my_function()
          assert_apify_called &Apify.ActorRuns.get_run/2
        end
      end

  The `use` macro also imports `mock_apify/3` and `generate_apify/2` for use in tests.
  """
  require ExUnit.Assertions

  alias Apify.Operation

  @doc false
  defmacro __using__(opts) do
    quote do
      import Apify.Testing,
        only: [
          assert_apify_called: 1,
          assert_apify_called: 2,
          generate_apify: 1,
          generate_apify: 2,
          generate_apify: 3,
          mock_apify: 2,
          mock_apify: 3
        ]

      setup do
        if unquote(opts)[:shared] do
          Apify.Testing.Store.set(Apify.Testing.Store.ETS)

          ExUnit.Callbacks.on_exit(fn ->
            Apify.Testing.Store.clear_calls(shared: true)
            Apify.Testing.Store.clear_mocks(shared: true)
          end)
        else
          Apify.Testing.Store.set(Apify.Testing.Store.Process)
        end

        :ok
      end
    end
  end

  # Convenience guard for generate_apify/3
  defguardp is_enum(value) when is_map(value) or is_list(value)

  #
  # Data Generation
  #

  @doc """
  Generate a struct for use in a test response

  The first argument is the module / schema you would like to generate. If there are multiple
  types available in the module, then the second argument can distinguish which to use (for
  example, `:full` for the type `Apify.ActorRun.full()`). It is also possible to override
  the generated fields with custom data.

  ## Examples

      iex> Apify.Testing.generate_apify(Apify.ActorRun)
      %Apify.ActorRun{}

      iex> Apify.Testing.generate_apify(Apify.Dataset, :full)
      %Apify.Dataset{}

      iex> Apify.Testing.generate_apify(Apify.ActorRun, id: "my-run-id")
      %Apify.ActorRun{id: "my-run-id"}

      iex> Apify.Testing.generate_apify(Apify.Dataset, :full, id: "my-dataset-id")
      %Apify.Dataset{id: "my-dataset-id"}

  """
  @spec generate_apify(module, atom, map | keyword) :: any
  def generate_apify(schema, type \\ :t, overrides \\ %{})

  def generate_apify(schema, overrides, _overrides) when is_enum(overrides) do
    overrides = if is_map(overrides), do: overrides, else: Enum.into(overrides, %{})

    generate(nil, nil, {schema, :t})
    |> override_fields(overrides)
  end

  def generate_apify(schema, type, overrides) when is_atom(type) and is_enum(overrides) do
    overrides = if is_map(overrides), do: overrides, else: Enum.into(overrides, %{})

    generate(nil, nil, {schema, type})
    |> override_fields(overrides)
  end

  def generate_apify(_schema, _type, _overrides) do
    raise ArgumentError, """
    Expected one of the following forms when calling generate_apify(...):

        generate_apify(SchemaModule)
        generate_apify(SchemaModule, :type)
        generate_apify(SchemaModule, :type, overrides)
        generate_apify(SchemaModule, overrides)

    Where overrides is an atom-keyed map or keyword list of fields to change in the result.
    """
  end

  @spec override_fields(struct | map, map) :: struct | map | no_return
  defp override_fields(%_{} = record, attrs), do: struct!(record, attrs)
  defp override_fields(%{} = record, attrs), do: Map.merge(record, attrs)

  @doc """
  Generate random data for use in a test response

  Data generated by this function will appear as if it were decoded by a plugin (for example
  `Apify.Plugin.TypedDecoder`). Including such a decoder in the stack is not necessary when the
  client uses this data.

  ## Examples

      iex> Apify.Testing.generate(nil, nil, {Apify.ActorRun, :full})
      %Apify.ActorRun{...}

      iex> Apify.Testing.generate(Apify.ActorRun, :id, :string)
      "abc123"

  """
  @spec generate(module, atom, Operation.type()) :: any
  def generate(schema, key, type)

  # Special cases
  def generate(_schema, :id, :string), do: random_string(24)
  def generate(_schema, :actId, :string), do: random_string(24)
  def generate(_schema, :userId, :string), do: random_string(24)
  def generate(_schema, :username, :string), do: "user-" <> random_string(8)
  def generate(_schema, :name, :string), do: "name-" <> random_string(8)

  def generate(_schema, :status, :string),
    do: Enum.random(["READY", "RUNNING", "SUCCEEDED", "FAILED"])

  # Primitive types
  def generate(_schema, _key, :boolean), do: Enum.random([true, false])
  def generate(_schema, _key, :integer), do: Enum.random(1..10)
  def generate(_schema, _key, :number), do: Enum.random(1..10) / 1.0
  def generate(_schema, _key, :string), do: random_string(10)
  def generate(_schema, _key, :null), do: nil

  # Unnatural types
  def generate(_schema, _key, :any), do: nil
  def generate(_schema, _key, :map), do: %{}

  # Compound types
  def generate(schema, key, [type]), do: [generate(schema, key, type)]
  def generate(_schema, _key, {:const, literal}), do: literal
  def generate(_schema, _key, {:enum, literals}), do: Enum.random(literals)

  def generate(schema, key, {:union, types}) do
    Enum.map(types, fn type ->
      fn -> generate(schema, key, type) end
    end)
    |> Enum.random()
    |> apply([])
  end

  def generate(_schema, _key, {module, struct_type}) do
    apply(module, :__fields__, [struct_type])
    |> Enum.map(fn {key, field_type} -> {key, generate(module, key, field_type)} end)
    |> then(fn fields -> struct!(module, fields) end)
  end

  #
  # Mocks
  #

  @doc """
  Mock a response for an API endpoint

  ## API Endpoint

  The API endpoint can be passed as a function call or using function capture syntax. If passed
  as a function call, the arguments must match exactly or use the special value `:_` to match any
  value. If passed using function capture syntax, only the arity will be matched. The options
  argument is not considered during these checks.

  ## Return Value

  As a return value for a mock, you can set a plain value or pass one of several function forms:

  * A zero-arity function will be evaluated a call time. Use this to perform lazy evaluation of
    the mock or encapsulate a generator.

  * A function with the same number of arguments as the original client operation (**not**
    including the final `opts` argument) will be called with the same arguments. Use this to
    perform assertions on the arguments or return a different value depending on the call.

  * A function with the same number of arguments as the original client operation (including the
    final `opts` argument) will be called with the same arguments and options. Use this to perform
    assertions on the arguments and options or return a different value depending on the call.

  In each case, the plain value — or the value returned from the function — should have one of the
  following forms:

      {:ok, data}
      {:ok, data, opts}
      {:error, error}
      {:error, error, opts}

  Where `data` is the response body and `error` is the error to return, and `opts` modifies the
  response. The available options are:

  * `code` (integer): Status code to include with the response.

  In addition, the following pre-defined error responses are available:

  * `{:error, :not_found}` will return an error matching Apify's standard "Not Found" response.
  * `{:error, :rate_limited}` with return an error matching a Apify API rate limited response.
  * `{:error, :unauthorized}` will return an error matching Apify's unauthorized response.

  ## Options

    * `cache`: For return values expressed as a function, whether the mock's result should be
      cached for future calls with the same arguments. Set to `false` if you want to guarantee
      that the mock function always runs (for example, if it contains assertions). Defaults to
      `true`.

  ## Examples

      mock_apify Apify.ActorRuns.get_run("my-run-id"), {:ok, %Apify.ActorRun{}}
      mock_apify Apify.ActorRuns.get_run("my-run-id-2"), {:ok, %Apify.ActorRun{}, code: 201}
      mock_apify Apify.ActorRuns.get_run("not-found"), {:error, :not_found}
      mock_apify Apify.ActorRuns.get_run("error"), {:error, %Apify.Error{}, code: 403}

      mock_apify &Apify.ActorRuns.get_run/2, fn -> {:ok, %Apify.ActorRun{}} end

      mock_apify &Apify.ActorRuns.get_run/2, fn run_id ->
        assert String.starts_with?(run_id, "my-run")
        {:ok, %Apify.ActorRun{id: run_id}}
      end

      mock_apify &Apify.ActorRuns.get_run/2, fn run_id, opts ->
        assert opts[:client][:api_token] == "my-token"
        {:ok, %Apify.ActorRun{id: run_id}}
      end

  """
  defmacro mock_apify(call, return_fn, opts \\ [])

  defmacro mock_apify({{:., _, [module, function]}, _, args}, return_fn, opts) do
    module = Macro.expand(module, __CALLER__)

    quote do
      Apify.Testing.put_mock(
        unquote(module),
        unquote(function),
        unquote(args),
        unquote(return_fn),
        unquote(opts)
      )
    end
  end

  defmacro mock_apify(
             {:&, _, [{:/, _, [{{:., _, [module, function]}, _, _}, arity]}]},
             return_fn,
             opts
           ) do
    module = Macro.expand(module, __CALLER__)

    quote do
      Apify.Testing.put_mock(
        unquote(module),
        unquote(function),
        unquote(arity),
        unquote(return_fn),
        unquote(opts)
      )
    end
  end

  @doc """
  Assert that a client operation was called

  ## API Endpoint

  The API endpoint can be passed as a function call or using function capture syntax. If passed
  as a function call, the arguments must match exactly or use the special value `:_` to match any
  value. If passed using function capture syntax, only the arity will be matched. The options
  argument is not considered during these checks.

  ## Options

    * `count`: The number of times the operation should have been called. If not provided, the
      assertion will pass if the operation was called at least once.

    * `shared`: Whether to check for calls in the shared storage. See the module documentation
      for more information.

  ## Examples

      assert_apify_called Apify.ActorRuns.get_run("my-run-id")
      assert_apify_called Apify.ActorRuns.get_run(:_)
      assert_apify_called &Apify.ActorRuns.get_run/2
      assert_apify_called &Apify.ActorRuns.get_run/2, count: 2
      assert_apify_called &Apify.ActorRuns.get_run/2, shared: true

  """
  defmacro assert_apify_called(call, opts \\ [])

  defmacro assert_apify_called({{:., _, [module, function]}, _, args}, opts) do
    module = Macro.expand(module, __CALLER__)

    quote do
      Apify.Testing.assert_called(
        unquote(module),
        unquote(function),
        unquote(args),
        unquote(opts)
      )
    end
  end

  defmacro assert_apify_called(
             {:&, _, [{:/, _, [{{:., _, [module, function]}, _, _}, arity]}]},
             opts
           ) do
    module = Macro.expand(module, __CALLER__)

    quote do
      Apify.Testing.assert_called(
        unquote(module),
        unquote(function),
        unquote(arity),
        unquote(opts)
      )
    end
  end

  #
  # Helpers
  #

  defp random_string(length) do
    alphabet = "abcdefghijklmnopqrstuvwxyz0123456789"
    Enum.map_join(1..length, fn _ -> Enum.random(String.graphemes(alphabet)) end)
  end

  #
  # Store Interface
  #

  defmodule Store do
    @moduledoc false

    @type call :: {module, atom, [any]}
    @type mock :: {module, atom, [any] | non_neg_integer, any, keyword}

    @callback get_calls() :: [call]
    @callback get_mocks(module, atom) :: [mock]
    @callback put_call(call) :: :ok
    @callback put_mock(mock) :: :ok
    @callback clear_calls() :: :ok
    @callback clear_mocks() :: :ok

    @process_key :apify_testing_store

    def set(store) do
      Process.put(@process_key, store)
    end

    def get_calls(opts \\ []) do
      store = if opts[:shared], do: Store.ETS, else: Process.get(@process_key, Store.Process)
      store.get_calls()
    end

    def get_mocks(module, function, opts \\ []) do
      store = if opts[:shared], do: Store.ETS, else: Process.get(@process_key, Store.Process)
      store.get_mocks(module, function)
    end

    def put_call(call, opts \\ []) do
      store = if opts[:shared], do: Store.ETS, else: Process.get(@process_key, Store.Process)
      store.put_call(call)
    end

    def put_mock(mock, opts \\ []) do
      store = if opts[:shared], do: Store.ETS, else: Process.get(@process_key, Store.Process)
      store.put_mock(mock)
    end

    def clear_calls(opts \\ []) do
      store = if opts[:shared], do: Store.ETS, else: Process.get(@process_key, Store.Process)
      store.clear_calls()
    end

    def clear_mocks(opts \\ []) do
      store = if opts[:shared], do: Store.ETS, else: Process.get(@process_key, Store.Process)
      store.clear_mocks()
    end
  end

  defmodule Store.Process do
    @moduledoc false
    @behaviour Store

    @calls_key :apify_testing_calls
    @mocks_key :apify_testing_mocks

    @impl true
    def get_calls do
      Process.get(@calls_key, [])
    end

    @impl true
    def get_mocks(module, function) do
      Process.get(@mocks_key, [])
      |> Enum.filter(fn {mod, fun, _, _, _} -> mod == module and fun == function end)
    end

    @impl true
    def put_call(call) do
      calls = Process.get(@calls_key, [])
      Process.put(@calls_key, [call | calls])
      :ok
    end

    @impl true
    def put_mock(mock) do
      mocks = Process.get(@mocks_key, [])
      Process.put(@mocks_key, [mock | mocks])
      :ok
    end

    @impl true
    def clear_calls do
      Process.put(@calls_key, [])
      :ok
    end

    @impl true
    def clear_mocks do
      Process.put(@mocks_key, [])
      :ok
    end
  end

  defmodule Store.ETS do
    @moduledoc false
    @behaviour Store

    @calls_table :apify_testing_calls
    @mocks_table :apify_testing_mocks

    @impl true
    def get_calls do
      case :ets.info(@calls_table) do
        :undefined -> []
        _ -> :ets.tab2list(@calls_table)
      end
    end

    @impl true
    def get_mocks(module, function) do
      case :ets.info(@mocks_table) do
        :undefined ->
          []

        _ ->
          :ets.match_object(@mocks_table, {module, function, :_, :_, :_})
      end
    end

    @impl true
    def put_call(call) do
      ensure_table(@calls_table, [:set, :public])
      :ets.insert(@calls_table, call)
      :ok
    end

    @impl true
    def put_mock(mock) do
      ensure_table(@mocks_table, [:set, :public])
      :ets.insert(@mocks_table, mock)
      :ok
    end

    @impl true
    def clear_calls do
      case :ets.info(@calls_table) do
        :undefined -> :ok
        _ -> :ets.delete_all_objects(@calls_table)
      end
    end

    @impl true
    def clear_mocks do
      case :ets.info(@mocks_table) do
        :undefined -> :ok
        _ -> :ets.delete_all_objects(@mocks_table)
      end
    end

    defp ensure_table(name, options) do
      case :ets.info(name) do
        :undefined -> :ets.new(name, options ++ [name])
        _ -> :ok
      end
    end
  end

  #
  # Internal API
  #

  @doc false
  def put_call(%Operation{} = operation) do
    {module, function, args} = Operation.get_caller(operation)
    Store.put_call({module, function, args})
  end

  @doc false
  def put_mock(module, function, args, return, opts \\ []) when is_list(opts) do
    Store.put_mock({module, function, args, return, opts})
  end

  @doc false
  def assert_called(module, function, args, opts \\ []) do
    calls = Store.get_calls(opts)

    matching_calls =
      Enum.filter(calls, fn {mod, fun, call_args} ->
        mod == module and fun == function and args_match?(args, call_args)
      end)

    count = Keyword.get(opts, :count)

    if count do
      ExUnit.Assertions.assert(
        length(matching_calls) == count,
        "Expected #{module}.#{function} to be called #{count} time(s), but it was called #{length(matching_calls)} time(s)"
      )
    else
      ExUnit.Assertions.assert(
        length(matching_calls) > 0,
        "Expected #{module}.#{function} to be called at least once, but it was not called"
      )
    end
  end

  @doc false
  def get_mock_result(%Operation{} = operation) do
    {module, function, args} = Operation.get_caller(operation)
    options = Operation.get_options(operation)

    Store.get_mocks(module, function)
    |> choose_mock(args)
    |> case do
      {_module, _function, ^args, return, _opts} ->
        evaluate_mock(return, args, options)

      {_module, _function, arity, return, opts} when is_integer(arity) ->
        if opts[:cache] == false do
          evaluate_mock(return, args, options)
        else
          result = evaluate_mock(return, args, options)
          put_mock(module, function, args, result, implicit: true)
          result
        end

      nil ->
        nil
    end
  end

  defp choose_mock(mocks, args) do
    # First, try to find an exact match for the args
    exact_match =
      Enum.find(mocks, fn
        {_module, _function, ^args, _return, _opts} -> true
        _ -> false
      end)

    if exact_match do
      exact_match
    else
      # Next, try to find a match with wildcards
      wildcard_match =
        Enum.find(mocks, fn
          {_module, _function, mock_args, _return, _opts} when is_list(mock_args) ->
            args_match?(mock_args, args)

          _ ->
            false
        end)

      if wildcard_match do
        wildcard_match
      else
        # Finally, try to find a match by arity
        Enum.find(mocks, fn
          {_module, _function, arity, _return, _opts} when is_integer(arity) ->
            arity == length(args)

          _ ->
            false
        end)
      end
    end
  end

  defp args_match?(expected, actual) when length(expected) != length(actual), do: false

  defp args_match?(expected, actual) do
    Enum.zip(expected, actual)
    |> Enum.all?(fn
      {:_, _} -> true
      {expected_arg, actual_arg} -> expected_arg == actual_arg
    end)
  end

  defp evaluate_mock(fun, _args, _opts) when is_function(fun, 0), do: fun.()
  defp evaluate_mock(fun, args, _opts) when is_function(fun, length(args)), do: apply(fun, args)

  defp evaluate_mock(fun, args, opts) when is_function(fun, length(args) + 1),
    do: apply(fun, args ++ [opts])

  defp evaluate_mock(return, _args, _opts), do: return
end
